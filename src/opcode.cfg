//* vim: filetype=txt: formatoptions-=c: formatoptions-=r: formatoptions-=o: syntax=m4

//* Pause program execution
alias hlt "vm.halted 1"

//* Stack Operations
alias push  "rpn ${1} dbpush"
alias pop   "rpn /vm.last_popped dbpop ="
alias dup   "rpn dbget dbpush"
alias dot   "pop; vm.print_cvar vm.last_popped"

alias vm.print_cvar "ECHO ${$1 !}"

//* Arithmetic Operations
alias add   "rpn dbpop dbpop + dbpush"
alias sub   "rpn dbpop dbpop exch - dbpush"
alias mul   "rpn dbpop dbpop * dbpush"
alias div   "rpn dbpop dbpop exch / dbpush"
alias pow   "rpn dbpop dbpop exch ** dbpush"
alias mod   "rpn dbpop dbpop exch % dbpush"
alias max   "rpn dbpop dbpop max dbpush"
alias min   "rpn dbpop dbpop min dbpush"

//* Boolean Operations
alias and   "rpn dbpop dbpop and dbpush"
alias or    "rpn dbpop dbpop or dbpush"
alias not   "rpn dbpop ${_rpn_not} dbpush"

//* Comparison Operations
alias iseq  "rpn dbpop dbpop == dbpush"
alias isgt  "rpn dbpop dbpop exch > dbpush"
alias isge  "rpn dbpop dbpop exch >= dbpush"
alias islt  "rpn dbpop dbpop exch < dbpush"
alias isle  "rpn dbpop dbpop exch <= dbpush"
alias isne  "rpn dbpop dbpop != dbpush"

//* Jump Instructions
alias jmp "rpn /vm.ip ${1 !} 1 - ="
alias jif "rpn \"//vm.ip ${1 !} 1 - =\" \"//vm.null 0 put\" dbpop when eval"

//* Jump to address specified by the stack head
alias jmp_vfs "rpn /vm.ip dbpop 1 - ="

//* Jump to address specified by the stack head,
//* only if stack(stack.pos - 1) == 1
alias jif_vfs "rpn \"//vm.ip dbpop 1 - =\" \"//vm.null 0 put\" dbpop dbpop exch dbpush when eval"

//* Variable Storing and loading.
//* store_l and load_l are for saving and loading local variable
//* these variable have local scope, associated with the frame
alias store_l "rpn /${vm.frame !}.${1 !} dbpop put"
alias load_l "rpn /${vm.frame !}.${1 !} get dbpush"

//* Global variables
//* These variables have global scope
alias store_g "rpn /${1 !} dbpop put"
alias load_g "rpn /${1 !} get dbpush"

//* load and store using key value from stack
alias store_vfs "rpn dbpop dbpop exch put"  //* void store_vfs(int key, int value)
alias load_vfs  "rpn dbpop get dbpush"      //* int load_vfs(int key))

//* Function calls and return
alias call "vm.rpush; jmp ${1 !}"
alias ret "rpn \"//vm.do /vm.rpop =\" \"//vm.do vm.log.error.InvalidRetOpcode =\" /vm.frame load when eval; vm.do_pending"

set vm.do ""
alias vm.do_pending "${vm.do !}"
alias vm.log.error.InvalidRetOpcode "VM_LOG_ERROR(`invalid ret instruction at address ${vm.ip !} frame ${vm.frame !}')"

//* call vector from stack - use the stack head as the
//* pointer to a function used for interrupt routines
alias call_vfs "vm.rpush; rpn /vm.ip dbpop 1 - ="

