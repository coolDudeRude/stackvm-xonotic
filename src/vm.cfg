//* vim: filetype=txt: formatoptions-=c: formatoptions-=r: formatoptions-=o: syntax=m4
// Stack Based Virtual Machine using Xonotic's builtin database and stack.
// by JiƒÅn
// repo: https://github.com/coolDudeRude/stackvm-xonotic

include(directives.cfg)

IMUTCVAR(VM_VERSION_MAJOR, 1)
IMUTCVAR(VM_VERSION_MINOR, 0)
IMUTCVAR(VM_VERSION_PATCH, 0)

VERSION(VM)

define(LOG_INFO, `^7[VM][^3INFO^7]:')
define(LOG_ERROR, `^7[VM][^1ERROR^7]:')

ifdef(`USE_CPRINT',
`#define ECHO cprint
define(ECHO, cprint)',
`#define ECHO echo
define(ECHO, echo)')

define(VM_LOG_INFO, `ECHO LOG_INFO $1')
define(VM_LOG_ERROR, `ECHO LOG_ERROR $1; vm.halted 1')

//* Initilize cvars to manage the VM's execution state.
set vm.clock    0.001   //* time interval after which the next instruction is ran
set vm.ip       0       //* instruction pointer
set vm.frame    0       //* frame counter, local variables are bound to frame
set vm.halted   0       //* halts the vm
set vm.sleeping 0       //* flag indicating the vm is sleeping

//* Frame Manager, creates a new frame each time it's called.
//* Which simply increments the FRAME_NUMBER cvar, the local
//* variables for the VM are attached to this frame number,
//* like: <frame-num>.<var-name>. This is how local variables
//* are stored inside the database.
//*
//* Each frame also contains the return address from where
//* the function call was made. (<frame-num>.return_address)
//* The start frame (zero frame) contains a null string for
//* return address.
//*
//* Use 'ISNULL' macro (defined in src/directives.cfg) to see
//* if the return address is null/valid or not.


//* Return address can be managed in two ways.
//* 1 - Store the return address inside a frame.
//*     which 'store_l' & 'load_l' can access.
//* 2 - Use a separate stack to keep track of return
//*     addresses for function calls. (TODO)

alias vm.rpush "rpn /vm.frame dup load 1 + = /vm.frame load /%s.return_address sprintf1s /vm.ip load put"
alias vm.rpop "rpn /vm.ip /vm.frame load /%s.return_address sprintf1s get = /vm.frame dup load 1 - ="

//* put null as the return address for 0th frame.
rpn /0.return_address '' put

//* VM main loop, responsible of executing the program.
alias vm.run "__vm.run.${vm.halted !}"
alias __vm.run.0 "vm.rom.${vm.ip !}; rpn /vm.ip dup load 1 + =; ifdef(`NO_CLOCK', `vm.run',`defer ${vm.clock !} \"vm.run\"')"
alias __vm.run.1 "ifdef(`DEBUG_MODE', `VM_LOG_INFO(`vm halted!')')"

//* Step through each instruction.
alias vm.step "__vm.step.${vm.halted !}"
alias __vm.step.0 "vm.rom.${vm.ip !}; rpn /vm.ip dup load 1 + ="
alias __vm.step.1 "VM_LOG_INFO(`vm halted!')"

//* Reset the VM to initial state.
alias vm.reset "vm.ip 0; vm.frame 0; vm.halted 0; vm.sleeping 0; dnl
ifdef(`ENABLE_DPI', `vm.program.counter 0;') dnl
ifdef(`DEBUG_MODE', `VM_LOG_INFO(`vm reset!')')"

//* Make the stackvm CPU wait for some time before resuming program execution.
ifdef(`NO_CLOCK',
`alias vm.sleep "VM_LOG_INFO(`compiled with ^2-DNO_CLOCK^7 sleep feature is not avaliable!')"',

`
alias vm.sleep "set vm.sleep.time ${1 !}; __vm.sleep.${vm.sleeping !}"
alias __vm.sleep.0 "vm.sleeping 1; set vm.sleeping_for ${vm.sleep.time !}; defer ${vm.sleep.time !} \"vm.clock ${vm.clock !}\"; vm.clock ${vm.sleep.time !}"
alias __vm.sleep.1 "VM_LOG_INFO(`vm already set to sleep for ${vm.sleeping_for !} second(s), cannot sleep again!')"
'
)

//* Dynamic programming interface
//* Provides the ability to write program through ingame console.
ifdef(`ENABLE_DPI',
`
//* address counter for program memory.
set vm.program.counter 0

//* binds a name / label to a address
//* useful for dynamically linked libraries.
alias label "rpn /${1 !} /${vm.program.counter !} put ifdef(`DEBUG_MODE', `; VM_LOG_INFO(`LABEL: ${1} -> ${vm.program.counter}')')"
alias s "alias vm.rom.${vm.program.counter !} \"${1- !}; dnl
ifdef(`DEBUG_MODE', `VM_LOG_INFO(`vm.rom.${vm.program.counter} -> ${1-}')')\"; dnl
ifdef(`DEBUG_MODE', `VM_LOG_INFO(`vm.rom.${vm.program.counter} -> ${1-}');')dnl
rpn /vm.program.counter dup load 1 + ="
')

include(opcode.cfg)
