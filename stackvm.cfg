// Stack Based Virtual Machine using Xonotic's builtin database and stack.
// by Jiān
// repo: https://github.com/coolDudeRude/stackvm-xonotic
//
// Suggested Reads:
// Xonotic Console Tips and tricks: https://forums.xonotic.org/showthread.php?tid=2987
// Xonotic rpn quakec source: https://gitlab.com/xonotic/xonotic-data.pk3dir/-/blob/master/qcsrc/common/command/rpn.qc
// Stack Machine on Wikipedia: https://en.wikipedia.org/wiki/Stack_machine
// Stack Based Virtual Machine written in Java: https://andreabergia.com/series/stack-based-virtual-machines/


//===========================================================================
// C preprocessor like directive
//===========================================================================
// Following provides C preprocessor like directive aliases
// Supported directive are:
//	1 - #define and #undef: 
//		Set and unset cvars respectively, this does not add 
//		fancy macro feature of C compiler. Although you can 
//		expand the cvar in the source cfg file and it would 
//		be replaced with the contents of the cvar. But the 
//		resulting code might behave in unexpexted ways, so
//		be mindful of that.
//
//		Example Usage:
//			#define _MATHCFG 1
//			#undef _MATHCFG
//
//
//	2 - #include:
//		Execute a cfg only if it exists.
//
//		Example Usage:
//			#include stackvm-xonotic/examples/fibonacci.cfg
//
//
//	3 - #ifdef and #ifndef with #else block and #endif:
//		#ifdef and #ifndef take cvar name, the cvar should contain 
//		positive integer for the if code block to execute. Empty 
//		cvars are considered not defined. In case of #ifdef if code 
//		block is executed when the cvar contains positive integer 
//		value greater than zero, otherwise the else block is executed.
//		It's opposite for #ifndef.
//
//		Example Usage:
//
//			#ifndef _MATHCFG
//			d #define _MATHCFG 1
//			d LABLE square
//			d s dup
//			d s mul
//			d s ret
//			#else
//			d echo math.cfg already included
//			#endif
//
//		NOTE: the "d" alias is used to send the section following 
//		it to the respective code block, so it isn't executed when 
//		the file is executed.
//
//
//	4 - #if with #else block and #endif: 
//		#if is similar to #ifdef and #ifndef the only difference is 
//		that #if takes rpn expression as an input instead of a cvar name.
//
//		Example Usage:
//			#define _SPEED_LIMIT 20
//
//			#if ${_SPEED_LIMIT} 20 >
//			d echo Speed exceeds the speed limit of ${_SPEED_LIMIT}m/s
//			#else
//			d echo Speed is within speed limit (${_SPEED_LIMIT}m/s)
//			#endif
//
//			This example is not that practicle, it just illustrates the usage.
//
//


// #define & #undef
alias #define 	"set ${1 !} \"${2- ?}\""
alias #undef 	"unset ${1 !}"

// #include
alias #include "rpn /__FILE_EXISTS__ /${1 !} fexists =; alias __INCLUDE_1__ \"exec ${1 !}\"; alias __INCLUDE_0__ \"\"; __INCLUDE__"
alias __INCLUDE__ "__INCLUDE_${__FILE_EXISTS__}__"
alias __INCLUDE_0__ ""
alias __INCLUDE_1__ ""

// Holders for IF ELSE code blocks and aliases
set __IF_CODE_BLOCK__ 	"" // store the action for the if path
set __ELSE_CODE_BLOCK__ "" // store the actions for the else path
set __action__ "_add_to_if_block"
set __preprocessor_action__ ""

alias _add_to_if_block "__IF_CODE_BLOCK__ \"${__IF_CODE_BLOCK__}; ${1- !}\";"
alias _add_to_else_block "__ELSE_CODE_BLOCK__ \"${__ELSE_CODE_BLOCK__}; ${1- !}\";"
alias _reset_code_blocks "__IF_CODE_BLOCK__ \"\"; __ELSE_CODE_BLOCK__ \"\";"

// alias d sends it's input to the preprocessor actions set in __action__ cvar.
alias d "${__action__} ${1- q}"

// #If <rpn-expression>
alias #if "rpn /__IF_EXPR_RESULT__ ${1- ?} =; _reset_code_blocks; __action__ \"_add_to_if_block\"; __preprocessor_action__ \"__if__\";"
alias __if__ "__if_${__IF_EXPR_RESULT__}__"
alias __if_1__ "${__IF_CODE_BLOCK__}"
alias __if_0__ "${__ELSE_CODE_BLOCK__}"

// TODO: add support for #elseif
alias #else 	"__action__ \"_add_to_else_block\";"
alias #endif	"${__preprocessor_action__}; __preprocessor_action__ \"\";"

// #ifdef <cvar_name>
alias #ifdef 	"rpn /__DEF_TRUE__ 0 0${$1 ?} 0 + 1 bound =; _reset_code_blocks; __action__ \"_add_to_if_block\"; __preprocessor_action__ \"__ifdef__\";"
alias __ifdef__ "__ifdef_${__DEF_TRUE__}__"
alias __ifdef_1__ "${__IF_CODE_BLOCK__}"
alias __ifdef_0__ "${__ELSE_CODE_BLOCK__}"

//		IMPORTANT NOTE: In xonotic version 0.8.6 and below the "logical not and bitwise not" operation 
//		of rpn needs two operands to work. Thus wherever logical not is used in stackvm the stack head 
//		is duplicated with dup operation and then logical not is used. This behavior will be fixed in 
//		the next stable release of xonotic. If you're using latest autobuild with fix to this issue,
//		then remove the "dup" operation from "not" and "#ifndef" alias. Otherwise stackvm might behave 
//		in unexpected ways.
//
//		See commit related to above mentioned issue: 
//		https://gitlab.com/xonotic/xonotic-data.pk3dir/-/commit/6046ba734ca103327860714b19bad78951dd2549
//
//		While not and #ifndef aliase can be changed manually to fix this problem, when the next stable 
//		version is released, however we can use the #if directive to set _rpn_not to either "not" or 
//		"dup not" depending on the xonotic gameversion cvar and expanding it wherever not is used.

#if ${gameversion} 806 <=
d echo [^2NOTE^7] Xonotic version is ${gameversion}: ^2dup not^3 -> ^2_rpn_not^7
d #define _rpn_not dup not
#else
d echo [^2NOTE^7] Xonotic version is ${gameversion}: ^2not^3 -> ^2_rpn_not^7
d #define _rpn_not not
#endif

// ifndef <cvar_name>
alias #ifndef 	"rpn /__DEF_TRUE__ 0 0${$1 ?} 0 + ${_rpn_not} 1 bound =; _reset_code_blocks; __action__ \"_add_to_if_block\"; __preprocessor_action__ \"__ifndef__\";"
alias __ifndef__ "__ifndef_${__DEF_TRUE__}__"
alias __ifndef_1__ "${__IF_CODE_BLOCK__}"
alias __ifndef_0__ "${__ELSE_CODE_BLOCK__}"



//===================================================================
// StackVM Implemetation
//===================================================================

set CLOCK_SPEED "0.001" // ~1KHz
set INSTRUCTION_POINTER "0"
set STACKVM_HALTED "0"
set STACKVM_IS_SLEEPING "0"
set STACKVM_BREAK_LINE "-1"
set FRAME_NUMBER "-1"

// Frame
alias init_frame "rpn /FRAME_NUMBER dup load 1 + = /FRAME_NUMBER load /%s.return_address sprintf1s /INSTRUCTION_POINTER load put;"

init_frame	// setup initial frame at script execution.

// Machine Oprations
alias hlt 	"set STACKVM_HALTED 1"

// Stack Operations
alias push 	"rpn ${1} dbpush"
alias pop 	"rpn /STACKVM_LAST_POP dbpop ="
alias dup 	"rpn dbget dbpush"

// Arithmetic Operations
alias add 	"rpn dbpop dbpop exch + dbpush"
alias sub	"rpn dbpop dbpop exch - dbpush"
alias mul	"rpn dbpop dbpop exch * dbpush"
alias div	"rpn dbpop dbpop exch / dbpush"
alias pow 	"rpn dbpop dbpop exch ** dbpush"
alias mod 	"rpn dbpop dbpop exch % dbpush"
alias max	"rpn dbpop dbpop exch max dbpush"
alias min	"rpn dbpop dbpop exch min dbpush"

// Boolean Operations
alias and 	"rpn dbpop dbpop and dbpush"
alias or 	"rpn dbpop dbpop or dbpush"
alias not 	"rpn dbpop ${_rpn_not} dbpush"

// Comparison Operations
alias iseq	"rpn dbpop dbpop exch == dbpush"
alias isgt 	"rpn dbpop dbpop exch > dbpush"
alias isge	"rpn dbpop dbpop exch >= dbpush"
alias islt	"rpn dbpop dbpop exch < dbpush"
alias isle	"rpn dbpop dbpop exch <= dbpush"
alias isne	"rpn dbpop dbpop exch != dbpush"

// JUMP Instructions
alias jmp 	"rpn /INSTRUCTION_POINTER ${1} 1 - ="
alias jif 	"rpn  \"//INSTRUCTION_POINTER ${1 !} 1 - =\" \"//svm.null 0 put\" dbpop when eval"

// JMP vector from stack head
alias jmp_vfs "rpn /INSTRUCTION_POINTER dbpop 1 - ="

// JMP if true vector from stack head
alias jif_vfs "rpn \"//INSTRUCTION_POINTER dbpop 1 - =\" \"//svm.null 0 put\" dbpop when eval"

// Variable Storing and loading.
// store_l and load_l are for saving and loading local variable
// these variable have local scope, associated with the frame
alias store_l 	"rpn /${FRAME_NUMBER}.${1} dbpop put"
alias load_l	"rpn /${FRAME_NUMBER}.${1} get dbpush"

// Global variables
// These variables have global scope
alias store_g 	"rpn /${1} dbpop put"
alias load_g 	"rpn /${1} get dbpush"

// load and store using key value from stack
alias store_vfs "rpn dbpop dbpop exch put"  // void store_vfs(int key, int value)
alias load_vfs 	"rpn dbpop get dbpush"		// int load_vfs(int key)

// Function calls and return
alias call 	"init_frame; jmp ${1}"
alias ret 	"rpn \"//__svm_do__ /__nothing__ = /INSTRUCTION_POINTER /FRAME_NUMBER load /%s.return_address sprintf1s get = /FRAME_NUMBER dup load 1 - =\" \"//STACKVM_HALTED 1 = /__svm_do__ /_svm_invalid_frame_error =\" /FRAME_NUMBER load when eval; __svm_do_pending__"

alias _svm_invalid_frame_error "echo [SVM: ^2InvalidFrameError^7]: Invalid frame for a return instruction at '${INSTRUCTION_POINTER}', the frame is '${FRAME_NUMBER}'"
alias __nothing__ ""
alias __svm_do_pending__ "${__svm_do__}"


// call vector from stack - use the stack head as the pointer to a function
// used for interrupt routines
alias call_vfs "init_frame; rpn /INSTRUCTION_POINTER dbpop 1 - ="

// print an interger from the stack head to console.
alias dot 		"rpn /STACKVM_OUT_BUFF dbpop =; print_cvar STACKVM_OUT_BUFF"
alias print_cvar "echo ${$1}"

// StackVM CPU, main
// Execute the program
alias run "__CPU_HALTED_${STACKVM_HALTED}__"

alias __CPU_HALTED_0__ "${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =; defer ${CLOCK_SPEED} \"__CPU_POST_EXEC__\""
alias __CPU_POST_EXEC__ "__CPU_HALTED_${STACKVM_HALTED}__"
alias __CPU_HALTED_1__ ""

// run progam with debug mode enabled
alias run_with_debug "__DEBUG_MODE_CPU_${STACKVM_HALTED}__"

alias __DEBUG_MODE_CPU_0__ "__DEBUG_MODE_EXTRA__; __DEBUG_CHECK_BREAK__; ${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =; defer ${CLOCK_SPEED} \"__DEBUG_MODE_CPU_POST_EXEC__\""
alias __DEBUG_MODE_CPU_POST_EXEC__ "__DEBUG_MODE_CPU_${STACKVM_HALTED}__"
alias __DEBUG_MODE_CPU_1__ "echo ^7[STACKVM]: ^2CPU halted.^7"
alias __DEBUG_MODE_EXTRA__ "echo ^7[STACKVM]: ^2executing ${INSTRUCTION_POINTER}^7"


// set breakpoint in code, to pause exectution when the INSTRUCTION_POINTER reaches that breakpoint
alias breakpoint "rpn /STACKVM_BREAK_LINE ${1} ="
alias __DEBUG_CHECK_BREAK__ "rpn /__BREAK_TRUE__ /INSTRUCTION_POINTER load /STACKVM_BREAK_LINE load 1 - == =; __DEBUG_BREAK__"
alias __DEBUG_BREAK__ "__DEBUG_BREAK_${__BREAK_TRUE__}__"
alias __DEBUG_BREAK_1__ "echo ^7[STACKVM DEBUG]: ^2reached breakpoint ${STACKVM_BREAK_LINE} stopping execution^7; hlt; defer 0.1 \"set STACKVM_HALTED 0\""
alias __DEBUG_BREAK_0__ ""


// step through the program
alias step "__CPU_STEP_${STACKVM_HALTED}__"
alias __CPU_STEP_0__ "echo ^7[STACKVM]: ^2executing ${INSTRUCTION_POINTER}^7; ${INSTRUCTION_POINTER}; rpn /INSTRUCTION_POINTER dup load 1 + =;"
alias __CPU_STEP_1__ "echo ^7[STACKVM]: ^1An halted cpu cannot execute instructions.^7"

// Reset CPU
alias reset "set INSTRUCTION_POINTER 0; set STACKVM_HALTED 0; set FRAME_NUMBER 0; set STACKVM_BREAK_LINE -1; set STACKVM_PROGRAM_POSITION 0; echo ^7[STACKVM]: ^2CPU reset complete.^7"

// Make the stackvm CPU wait for some time before resuming program execution.
alias sleep "set __sleep_time__ ${1}; __SLEEP_CPU_${STACKVM_IS_SLEEPING}__"
alias __SLEEP_CPU_0__ "set STACKVM_IS_SLEEPING 1; defer ${__sleep_time__} \"set CLOCK_SPEED ${CLOCK_SPEED}; set STACKVM_IS_SLEEPING 0\"; set CLOCK_SPEED ${__sleep_time__}"
alias __SLEEP_CPU_1__ "echo ^7[STACKVM]: ^1CPU already sleeping...^7"



// Writing Program
set STACKVM_PROGRAM_POSITION "0"
alias s "alias ${STACKVM_PROGRAM_POSITION} \"${1-}\"; rpn /STACKVM_PROGRAM_POSITION dup load 1 + ="
alias label "rpn /${1} /${STACKVM_PROGRAM_POSITION} put"
alias origin "rpn /STACKVM_PROGRAM_POSITION ${1} ="
